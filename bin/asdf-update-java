#!/usr/bin/env groovy
// Written by Leonard Br√ºnings
// From https://gist.github.com/leonard84/13e14f98458cfbc17cc44d882e6f85d5

import groovy.transform.Immutable

import java.util.regex.Pattern

@Immutable
class Version implements Comparable<Version> {
    static Pattern NAME_AND_MAJOR_VERSION = ~/^(?<nameVersionPrefix>\w+-(?<major>\d+))(?<remainder>.*)/
    static Pattern VERSION_NUMBER_ELEMENT = ~/\D*(\d+)\D*/
    String version
    String prefix
    int major
    List<Integer> components

    static Version parse(String version) {
        def matcher = NAME_AND_MAJOR_VERSION.matcher(version)
        if (!matcher.matches()) {
            return null
        }
        def prefix = matcher.group("nameVersionPrefix")

        def major = Integer.valueOf(matcher.group("major"))
        List<Integer> components = [major]
        def remainderMatcher = VERSION_NUMBER_ELEMENT.matcher(matcher.group("remainder"))
        while (remainderMatcher.find()) {
            try {
                components.add(Integer.valueOf(remainderMatcher.group(1)))
            } catch (NumberFormatException ignored) {
                // ignore
                println "Can't parse '$version' element: ${remainderMatcher.group(1)}"
                return null
            }
        }
        return new Version(version, prefix, major, components)
    }

    @Override
    int compareTo(Version o) {
        if (prefix != o.prefix) {
            throw new IllegalArgumentException("Cannot compare versions with different prefixes: $prefix and $o.prefix")
        }
        for (int i = 0; i < components.size(); i++) {
            if (i >= o.components.size()) {
                return 1
            }
            int result = components[i] <=> o.components[i]
            if (result != 0) {
                return result
            }
        }
        return components.size() <=> o.components.size()
    }
}


List<String> installed = "asdf list java".execute().text.split()
println "Currently installed:"
println installed.join("\n")

def installedVersions = installed
    .collect {
        Version.parse(it)
    }
    .findAll()

def allVersions = "asdf list-all java".execute().text.split()
    .collect {
        Version.parse(it)
    }
    .findAll()
    .groupBy {
        it.prefix
    }

List<Version> upToDate = []
Map<String, Version> availableUpdates = installedVersions.collectEntries {
    def latest = allVersions[it.prefix].max()
    if (latest > it) {
        return [(it.version): latest]
    }
    upToDate << it
    return [:]
}

println "\nUpgrades available:"
availableUpdates.each { from, to ->
    println "$from -> $to.version"
}

println "\n-----------------------------\n"

availableUpdates.each { from, to ->
    println "asdf install java $to.version"
    println "asdf uninstall java $from"
}
println "\n-----------------------------\n"

(upToDate + availableUpdates.values()).sort { "${it.major}-${it.prefix}" }
    .each { println "export JDK${it.major}=\$(asdf where java ${it.version})" }
